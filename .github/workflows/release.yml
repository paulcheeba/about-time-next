name: Release About Time

on:
  push:
    tags:
      - "v*.*.*"             # e.g., v13.0.4
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to release (e.g. v13.0.4). Leave blank to auto-detect."
        required: false
        default: ""

permissions:
  contents: write

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure jq & zip & gh
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq zip

      - name: Determine TAG and VERSION
        id: detect
        run: |
          set -euo pipefail
          REF_NAME="${GITHUB_REF_NAME:-}"            # e.g., v13.0.4 or 13.0.4 or main
          INPUT_TAG="${{ github.event.inputs.tag || '' }}"
          VERSION_JSON=$(jq -r '.version' module.json)
          # Prefer: pushed tag → input tag → branch (if looks like 13.0.4 and no tag exists) → v<module.json.version>
          if [[ "$REF_NAME" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            TAG="$REF_NAME"
          elif [[ "$INPUT_TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            TAG="$INPUT_TAG"
          else
            # If current ref is a version-like branch (e.g., 13.0.4) AND tag doesn't exist, we'll create it later
            if [[ "$REF_NAME" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              TAG="v${REF_NAME}"
            else
              TAG="v${VERSION_JSON}"
            fi
          fi
          VERSION="${TAG#v}"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "ref_name=$REF_NAME" >> "$GITHUB_OUTPUT"
          echo "Using TAG=$TAG VERSION=$VERSION REF=$REF_NAME"

      - name: Create tag if missing (from version-like branch)
        run: |
          set -euo pipefail
          TAG="${{ steps.detect.outputs.tag }}"
          REF="${{ steps.detect.outputs.ref_name }}"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists."
          else
            if [[ "$REF" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "Creating tag $TAG from branch $REF"
              git tag -a "$TAG" -m "Release $TAG"
              git push origin "$TAG"
            else
              echo "No version-like branch; not creating a new tag."
            fi
          fi

      - name: Patch module.json (download only)
        id: patch
        run: |
          set -euo pipefail
          REPO="${GITHUB_REPOSITORY}"
          TAG="${{ steps.detect.outputs.tag }}"
          VERSION="${{ steps.detect.outputs.version }}"
          ZIPNAME="about-time-v${VERSION}.zip"
          EXPECT_DL="https://github.com/${REPO}/releases/download/${TAG}/${ZIPNAME}"
          CUR_DL=$(jq -r '.download' module.json)
          if [ "$CUR_DL" != "$EXPECT_DL" ]; then
            echo "Updating download URL -> $EXPECT_DL"
            tmp=$(mktemp)
            jq --arg dl "$EXPECT_DL" '.download = $dl' module.json > "$tmp"
            mv "$tmp" module.json
          else
            echo "Download URL already correct."
          fi
          echo "zipname=$ZIPNAME" >> "$GITHUB_OUTPUT"

      - name: Basic checks
        run: |
          set -euo pipefail
          test -f module.json
          test -f about-time.js
          test -f vars.js
          test -d module
          test -d templates
          test -d lang

      - name: Build ZIP
        id: zip
        run: |
          set -euo pipefail
          ZIP="${{ steps.patch.outputs.zipname }}"
          DOCS=()
          [ -f README.md ] && DOCS+=("README.md")
          [ -f LICENSE ] && DOCS+=("LICENSE")
          [ -f LICENSE.md ] && DOCS+=("LICENSE.md")
          zip -r "$ZIP" module.json about-time.js vars.js module templates lang "${DOCS[@]}" >/dev/null
          echo "zip=$ZIP" >> "$GITHUB_OUTPUT"

      - name: Check if release exists
        id: rel
        run: |
          set -euo pipefail
          TAG="${{ steps.detect.outputs.tag }}"
          API="https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/${TAG}"
          if gh api -H "Accept: application/vnd.github+json" "$API" >/tmp/release.json 2>/dev/null; then
            echo "exists=true"  >> "$GITHUB_OUTPUT"
            echo "rel_id=$(jq -r '.id' /tmp/release.json)" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Delete same-named assets if release exists
        if: steps.rel.outputs.exists == 'true'
        run: |
          set -euo pipefail
          REL_ID="${{ steps.rel.outputs.rel_id }}"
          ZIP="${{ steps.zip.outputs.zip }}"
          gh api -H "Accept: application/vnd.github+json" "/repos/${GITHUB_REPOSITORY}/releases/${REL_ID}/assets" >/tmp/assets.json
          for NAME in "$ZIP" "module.json"; do
            ASSET_ID=$(jq -r --arg NAME "$NAME" '.[] | select(.name==$NAME) | .id' /tmp/assets.json || true)
            if [ -n "$ASSET_ID" ] && [ "$ASSET_ID" != "null" ]; then
              echo "Deleting existing asset $ASSET_ID ($NAME)"
              gh api -X DELETE -H "Accept: application/vnd.github+json" "/repos/${GITHUB_REPOSITORY}/releases/assets/${ASSET_ID}"
            else
              echo "No existing asset named $NAME to delete."
            fi
          done

      - name: Create or Update Release and upload assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.detect.outputs.tag }}
          name: ${{ steps.detect.outputs.tag }}          # You will edit the title & notes manually
          draft: false
          prerelease: false
          files: |
            ${{ steps.zip.outputs.zip }}
            module.json
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
